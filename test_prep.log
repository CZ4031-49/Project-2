DEBUG:root:Current query: 
        SELECT s_suppkey, SUM(p_retailprice)
        FROM supplier s, part p, partsupp ps
        WHERE ps.ps_partkey = p.p_partkey AND
              ps.ps_suppkey = s.s_suppkey
        GROUP BY s.s_suppkey 
        
DEBUG:root:length of plans for current query: 34
DEBUG:root:Annotated best plan:  {
    "Plan": {
        "Async Capable": false,
        "Contain Relation": [
            "supplier",
            "part",
            "partsupp"
        ],
        "Explanation": "A general aggregation node without specifying aggregation method.",
        "Group Key": [
            "s.s_suppkey"
        ],
        "Node Type": "Aggregate",
        "Parallel Aware": false,
        "Partial Mode": "Simple",
        "Plan Rows": 10000,
        "Plan Width": 36,
        "Plans": [
            {
                "Async Capable": false,
                "Contain Relation": [
                    "supplier",
                    "part",
                    "partsupp"
                ],
                "Explanation": "Node type Nested Loop: \nOnly one operand of this index join has index scan on original relation, and the one without using index has size 800000.Without knowing distinct values on join condition for the operand that uses index, since this size is small, heuristically index join performs better as only few index fetches are expected on relation with index. ",
                "Inner Unique": false,
                "Join Filter": "(ps.ps_suppkey = s.s_suppkey)",
                "Join Type": "Inner",
                "Node Type": "Nested Loop",
                "Parallel Aware": false,
                "Parent Relationship": "Outer",
                "Plan Rows": 800000,
                "Plan Width": 10,
                "Plans": [
                    {
                        "Alias": "s",
                        "Async Capable": false,
                        "Contain Relation": [
                            "supplier"
                        ],
                        "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is no condition on supplier index scan. Without knowing predecessors of this node, this index scan is likely to be selectedas there is likely to be a join that has condition on this relation, or has build relation very small so a join fetching probe relation index is prefered. \nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (ps.ps_suppkey = s.s_suppkey). \n ",
                        "Has Child With Index": true,
                        "Index Name": "supplier_pkey",
                        "Node Type": "Index Scan",
                        "Parallel Aware": false,
                        "Parent Relationship": "Outer",
                        "Plan Rows": 10000,
                        "Plan Width": 4,
                        "Relation Name": "supplier",
                        "Scan Direction": "Forward",
                        "Startup Cost": 10000000000.28,
                        "Total Cost": 10000000494.32
                    },
                    {
                        "Async Capable": false,
                        "Contain Relation": [
                            "part",
                            "partsupp"
                        ],
                        "Explanation": "Node type Materialize: \nOperation Materialize emits intermediate result from previous node(s) ['Nested Loop'].\nIt has expected size 800000, as it is a small batch considering database capacity, materialize emit is the best to handle this intermediate result (as this batch size can be emitted at once).",
                        "Node Type": "Materialize",
                        "Parallel Aware": false,
                        "Parent Relationship": "Inner",
                        "Plan Rows": 800000,
                        "Plan Width": 10,
                        "Plans": [
                            {
                                "Async Capable": false,
                                "Contain Relation": [
                                    "part",
                                    "partsupp"
                                ],
                                "Explanation": "Node type Nested Loop: \nThis nested loop join has two operands that does index scan on original relation, hence this nested loop is a zig-zag join on both indices with this filter: (p.p_partkey = ps.ps_partkey). ",
                                "Inner Unique": false,
                                "Join Filter": "(p.p_partkey = ps.ps_partkey)",
                                "Join Type": "Inner",
                                "Node Type": "Nested Loop",
                                "Parallel Aware": false,
                                "Parent Relationship": "Outer",
                                "Plan Rows": 800000,
                                "Plan Width": 10,
                                "Plans": [
                                    {
                                        "Alias": "p",
                                        "Async Capable": false,
                                        "Contain Relation": [
                                            "part"
                                        ],
                                        "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is no condition on part index scan. Without knowing predecessors of this node, this index scan is likely to be selectedas there is likely to be a join that has condition on this relation, or has build relation very small so a join fetching probe relation index is prefered. \nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (p.p_partkey = ps.ps_partkey). \n ",
                                        "Has Child With Index": true,
                                        "Index Name": "part_pkey",
                                        "Node Type": "Index Scan",
                                        "Parallel Aware": false,
                                        "Parent Relationship": "Outer",
                                        "Plan Rows": 200000,
                                        "Plan Width": 10,
                                        "Relation Name": "part",
                                        "Scan Direction": "Forward",
                                        "Startup Cost": 10000000000.42,
                                        "Total Cost": 10000009351.42
                                    },
                                    {
                                        "Async Capable": false,
                                        "Contain Relation": [
                                            "partsupp"
                                        ],
                                        "Explanation": "Node type Materialize: \nOperation Materialize emits intermediate result from previous node(s) ['Index Scan'].\nIt has expected size 800000, as it is a small batch considering database capacity, materialize emit is the best to handle this intermediate result (as this batch size can be emitted at once).\nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (p.p_partkey = ps.ps_partkey). \n ",
                                        "Has Child With Index": true,
                                        "Node Type": "Materialize",
                                        "Parallel Aware": false,
                                        "Parent Relationship": "Inner",
                                        "Plan Rows": 800000,
                                        "Plan Width": 8,
                                        "Plans": [
                                            {
                                                "Alias": "ps",
                                                "Async Capable": false,
                                                "Contain Relation": [
                                                    "partsupp"
                                                ],
                                                "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is no condition on partsupp index scan. Without knowing predecessors of this node, this index scan is likely to be selectedas there is likely to be a join that has condition on this relation, or has build relation very small so a join fetching probe relation index is prefered. ",
                                                "Has Child With Index": true,
                                                "Index Name": "partsupp_pkey",
                                                "Node Type": "Index Scan",
                                                "Parallel Aware": false,
                                                "Parent Relationship": "Outer",
                                                "Plan Rows": 800000,
                                                "Plan Width": 8,
                                                "Relation Name": "partsupp",
                                                "Scan Direction": "Forward",
                                                "Startup Cost": 10000000000.42,
                                                "Total Cost": 10000074340.75
                                            }
                                        ],
                                        "Startup Cost": 10000000000.42,
                                        "Total Cost": 10000081465.75
                                    }
                                ],
                                "Startup Cost": 30000000000.85,
                                "Total Cost": 33025085692.17
                            }
                        ],
                        "Startup Cost": 30000000000.85,
                        "Total Cost": 33025093599.17
                    }
                ],
                "Startup Cost": 50000000001.13,
                "Total Cost": 53184158186.49
            }
        ],
        "Startup Cost": 50000000001.13,
        "Strategy": "Sorted",
        "Total Cost": 53184162311.49
    }
}
DEBUG:root:Current query:  
        SELECT s_address, p_partkey
        FROM supplier s, part p, partsupp ps
        WHERE
            ps.ps_partkey = p.p_partkey AND
            ps.ps_suppkey = s.s_suppkey AND
            p.p_retailprice < 500 AND
            s.s_phone != '800-807-9579'
        ORDER BY p_partkey

        
DEBUG:root:length of plans for current query: 34
DEBUG:root:Annotated best plan:  {
    "Plan": {
        "Async Capable": false,
        "Contain Relation": [
            "partsupp",
            "part",
            "supplier"
        ],
        "Explanation": "Node type Nested Loop: \nOnly one operand of this index join has index scan on original relation, and the one without using index has size 80.Without knowing distinct values on join condition for the operand that uses index, since this size is small, heuristically index join performs better as only few index fetches are expected on relation with index. ",
        "Inner Unique": true,
        "Join Filter": "(ps.ps_suppkey = s.s_suppkey)",
        "Join Type": "Inner",
        "Node Type": "Nested Loop",
        "Parallel Aware": false,
        "Plan Rows": 80,
        "Plan Width": 29,
        "Plans": [
            {
                "Async Capable": false,
                "Contain Relation": [
                    "partsupp",
                    "part"
                ],
                "Explanation": "Node type Nested Loop: \nThis nested loop join has two operands that does index scan on original relation, hence this nested loop is a zig-zag join on both indices with this filter: (p.p_partkey = ps.ps_partkey). ",
                "Inner Unique": true,
                "Join Filter": "(p.p_partkey = ps.ps_partkey)",
                "Join Type": "Inner",
                "Node Type": "Nested Loop",
                "Parallel Aware": false,
                "Parent Relationship": "Outer",
                "Plan Rows": 80,
                "Plan Width": 8,
                "Plans": [
                    {
                        "Alias": "ps",
                        "Async Capable": false,
                        "Contain Relation": [
                            "partsupp"
                        ],
                        "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is no condition on partsupp index scan. Without knowing predecessors of this node, this index scan is likely to be selectedas there is likely to be a join that has condition on this relation, or has build relation very small so a join fetching probe relation index is prefered. \nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (p.p_partkey = ps.ps_partkey). \n ",
                        "Has Child With Index": true,
                        "Index Name": "partsupp_pkey",
                        "Node Type": "Index Scan",
                        "Parallel Aware": false,
                        "Parent Relationship": "Outer",
                        "Plan Rows": 800000,
                        "Plan Width": 8,
                        "Relation Name": "partsupp",
                        "Scan Direction": "Forward",
                        "Startup Cost": 10000000000.42,
                        "Total Cost": 10000074340.75
                    },
                    {
                        "Async Capable": false,
                        "Contain Relation": [
                            "part"
                        ],
                        "Explanation": "Node type Materialize: \nOperation Materialize emits intermediate result from previous node(s) ['Index Scan'].\nIt has expected size 20, as it is a small batch considering database capacity, materialize emit is the best to handle this intermediate result (as this batch size can be emitted at once).\nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (p.p_partkey = ps.ps_partkey). \n ",
                        "Has Child With Index": true,
                        "Node Type": "Materialize",
                        "Parallel Aware": false,
                        "Parent Relationship": "Inner",
                        "Plan Rows": 20,
                        "Plan Width": 4,
                        "Plans": [
                            {
                                "Alias": "p",
                                "Async Capable": false,
                                "Contain Relation": [
                                    "part"
                                ],
                                "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is a condition (p_retailprice < '500'::numeric) that can be pushed down the plan tree specifically for this relation part.\nWith this condition, index scan is selected since either there's an efficient eg. clustered index on condition attribute(s), or expected output from scan is small enough (in this case expected output tuples = 20).\nSince database capability can varies a lot, it is difficult for this annotatorto specifically decide which one is the most likely reason, or both. ",
                                "Filter": "(p_retailprice < '500'::numeric)",
                                "Has Child With Index": true,
                                "Index Name": "part_pkey",
                                "Node Type": "Index Scan",
                                "Parallel Aware": false,
                                "Parent Relationship": "Outer",
                                "Plan Rows": 20,
                                "Plan Width": 4,
                                "Relation Name": "part",
                                "Scan Direction": "Forward",
                                "Startup Cost": 10000000000.42,
                                "Total Cost": 10000009851.42
                            }
                        ],
                        "Startup Cost": 10000000000.42,
                        "Total Cost": 10000009851.52
                    }
                ],
                "Startup Cost": 30000000000.85,
                "Total Cost": 30000324191.14
            },
            {
                "Async Capable": false,
                "Contain Relation": [
                    "supplier"
                ],
                "Explanation": "Node type Materialize: \nOperation Materialize emits intermediate result from previous node(s) ['Index Scan'].\nIt has expected size 9999, as it is a small batch considering database capacity, materialize emit is the best to handle this intermediate result (as this batch size can be emitted at once).\nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (ps.ps_suppkey = s.s_suppkey). \n ",
                "Has Child With Index": true,
                "Node Type": "Materialize",
                "Parallel Aware": false,
                "Parent Relationship": "Inner",
                "Plan Rows": 9999,
                "Plan Width": 29,
                "Plans": [
                    {
                        "Alias": "s",
                        "Async Capable": false,
                        "Contain Relation": [
                            "supplier"
                        ],
                        "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is a condition (s_phone <> '800-807-9579'::bpchar) that can be pushed down the plan tree specifically for this relation supplier.\nWith this condition, index scan is selected since either there's an efficient eg. clustered index on condition attribute(s), or expected output from scan is small enough (in this case expected output tuples = 9999).\nSince database capability can varies a lot, it is difficult for this annotatorto specifically decide which one is the most likely reason, or both. ",
                        "Filter": "(s_phone <> '800-807-9579'::bpchar)",
                        "Has Child With Index": true,
                        "Index Name": "supplier_pkey",
                        "Node Type": "Index Scan",
                        "Parallel Aware": false,
                        "Parent Relationship": "Outer",
                        "Plan Rows": 9999,
                        "Plan Width": 29,
                        "Relation Name": "supplier",
                        "Scan Direction": "Forward",
                        "Startup Cost": 10000000000.28,
                        "Total Cost": 10000000519.32
                    }
                ],
                "Startup Cost": 10000000000.28,
                "Total Cost": 10000000569.31
            }
        ],
        "Startup Cost": 50000000001.13,
        "Total Cost": 50000336734.25
    }
}
DEBUG:root:Current query: 
        SELECT * 
        FROM customer c JOIN orders o 
        ON o.o_custkey=c.c_custkey 
        WHERE c.c_custkey < 100 
        LIMIT 10
        
DEBUG:root:length of plans for current query: 25
DEBUG:root:Annotated best plan:  {
    "Plan": {
        "Async Capable": false,
        "Contain Relation": [
            "orders",
            "customer"
        ],
        "Explanation": "Node type Limit: \nThis node is added in one-to-one correspondence of a LIMIT or OFFSET clause in the SELECT query.",
        "Node Type": "Limit",
        "Parallel Aware": false,
        "Plan Rows": 10,
        "Plan Width": 267,
        "Plans": [
            {
                "Async Capable": false,
                "Contain Relation": [
                    "orders",
                    "customer"
                ],
                "Explanation": "Node type Nested Loop: \nOnly one operand of this index join has index scan on original relation, and the one without using index has size 1500000.Without knowing distinct values on join condition for the operand that uses index, since this size is small, heuristically index join performs better as only few index fetches are expected on relation with index. ",
                "Inner Unique": true,
                "Join Filter": "(c.c_custkey = o.o_custkey)",
                "Join Type": "Inner",
                "Node Type": "Nested Loop",
                "Parallel Aware": false,
                "Parent Relationship": "Outer",
                "Plan Rows": 940,
                "Plan Width": 267,
                "Plans": [
                    {
                        "Alias": "o",
                        "Async Capable": false,
                        "Contain Relation": [
                            "orders"
                        ],
                        "Explanation": "Node type Seq Scan: \n",
                        "Node Type": "Seq Scan",
                        "Parallel Aware": false,
                        "Parent Relationship": "Outer",
                        "Plan Rows": 1500000,
                        "Plan Width": 108,
                        "Relation Name": "orders",
                        "Startup Cost": 10000000000.0,
                        "Total Cost": 10000041182.0
                    },
                    {
                        "Async Capable": false,
                        "Contain Relation": [
                            "customer"
                        ],
                        "Explanation": "Node type Materialize: \nOperation Materialize emits intermediate result from previous node(s) ['Index Scan'].\nIt has expected size 94, as it is a small batch considering database capacity, materialize emit is the best to handle this intermediate result (as this batch size can be emitted at once).\nThis node that has index scan in it child nodes is used by its direct parent node as nested loop join, with a condition (c.c_custkey = o.o_custkey). \n ",
                        "Has Child With Index": true,
                        "Node Type": "Materialize",
                        "Parallel Aware": false,
                        "Parent Relationship": "Inner",
                        "Plan Rows": 94,
                        "Plan Width": 159,
                        "Plans": [
                            {
                                "Alias": "c",
                                "Async Capable": false,
                                "Contain Relation": [
                                    "customer"
                                ],
                                "Explanation": "Node type Index Scan: \nThis is an Index Scan node.\nThere is no condition on customer index scan. Without knowing predecessors of this node, this index scan is likely to be selectedas there is likely to be a join that has condition on this relation, or has build relation very small so a join fetching probe relation index is prefered. ",
                                "Has Child With Index": true,
                                "Index Cond": "(c_custkey < 100)",
                                "Index Name": "customer_pkey",
                                "Node Type": "Index Scan",
                                "Parallel Aware": false,
                                "Parent Relationship": "Outer",
                                "Plan Rows": 94,
                                "Plan Width": 159,
                                "Relation Name": "customer",
                                "Scan Direction": "Forward",
                                "Startup Cost": 10000000000.42,
                                "Total Cost": 10000000012.07
                            }
                        ],
                        "Startup Cost": 10000000000.42,
                        "Total Cost": 10000000012.54
                    }
                ],
                "Startup Cost": 30000000000.42,
                "Total Cost": 30002156180.5
            }
        ],
        "Startup Cost": 30000000000.42,
        "Total Cost": 30000022938.51
    }
}
